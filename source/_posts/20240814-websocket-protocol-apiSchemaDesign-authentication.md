---
title: Dig in WebSocket; Protocol, API Design, and Security
date: 2024-08-15 00:24:11
categories: WebSocket
tags:
- WebSocket
---


# Dig in WebSocket: Protocol, API Design, and  Security

## WebSocket

WebSocket operate at the Application layer in both the OSI(Layer 7) and TCP/IP(Layer 4) models.

```sh
 HTTP       WebSocket
--------------------
        TCP
--------------------
        IP
--------------------
Network access Layer
```

The WebSocket protocol enables full-duplex communication, allowing data to be sent and received simultaneously over a single, persistent connection. This capability is ideal for real-time applications such as chat systems, live notifications, and online gaming.

## How to Establish a WebSocket Connection

A WebSocket server is essentially an application that listens on any port of a TCP, following a designated protocol. A WebSocket connection starts with an HTTP handshake and then upgrades to a persistent TCP connection. Once this connection is established, it remains open for an extended period, allowing real-time communication between the client and server.

1. **Client handshake request**

    Client sent a HTTP request with method `GET` for upgrading the connection from HTTP to WebSocket.

    ```go
    GET /chat HTTP/1.1
    Host: example.com:8000
    Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
    Sec-WebSocket-Version: 13
    ```

    - The **`Sec-WebSocket-Key`** header is used  to ensure that the client and server are speaking the WebSocket protocol.
        It is a base64 encoded value that is generated by randomly selecting 16-byte value as a nonce.
    - The **`Sec-WebSocket-Version`** header indicates the version of the WebSocket protocol that the client supports.
    - The HTTP version must be 1.1 or greater because earlier versions of HTTP do not support the necessary features for upgrading to WebSocket.
    - Origin header is supplied if the client is a web browser, and CORS issues must also be addressed.


2. **Server handshake response**

    If the server supports WebSocket, it responds with an upgrade header, establishing a WebSocket connection. 

    ```go
    HTTP/1.1 101 Switching Protocols
    Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
    ```

    -  **`Sec-WebSocket-Accept`** = concatenate the client's `Sec-WebSocket-Key` and the string "`258EAFA5-E914-47DA-95CA-C5AB0DC85B11`" together (it's a "[magic string](https://en.wikipedia.org/wiki/Magic_string)"), take the SHA-1 hash of the result, and return the base64 encoding of that hash.

    The `Sec-WebSocket-Key` and `Sec-WebSocket-Accept` headers are part of the security mechanism to ensure that the WebSocket handshake is being conducted correctly and to prevent certain types of attacks.
      - Protocol Upgrade Validation: confirms that the server has correctly understood the WebSocket handshake request(server indeed support WebSocket).
      - Security and Authentication: This value is used to ensure that the handshake request is valid and is not replayed by a malicious entity.


3. **Exchanging data frames**

    Websockets have four states: `connecting`, `open`, `closing` and `closed`. All communication between clients and servers takes place though the use of the websocket `frame`.
    ```sh
    Frame format:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-------+-+-------------+-------------------------------+
        |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
        |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
        |N|V|V|V|       |S|             |   (if payload len==126/127)   |
        | |1|2|3|       |K|             |                               |
        +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
        |     Extended payload length continued, if payload len == 127  |
        + - - - - - - - - - - - - - - - +-------------------------------+
        |                               |Masking-key, if MASK set to 1  |
        +-------------------------------+-------------------------------+
        | Masking-key (continued)       |          Payload Data         |
        +-------------------------------- - - - - - - - - - - - - - - - +
        :                     Payload Data continued ...                :
        + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
        |                     Payload Data continued ...                |
        +---------------------------------------------------------------+
    ```

    For more detail about each field: [The WebSocket API and protocol explained](https://ably.com/topic/websockets#how-do-web-sockets-work), [rfc6455](https://datatracker.ietf.org/doc/html/rfc6455#section-5.2)

    - FIN bit: webSocket protocol makes fragmentation possible via this field, which indicates whether the frame is the final fragment in a WebSocket message.
    - Opcode: determines how to interpret the payload data.
        - 0: continuation frame; continues the payload from the previous frame.
        - 1: text frame (UTF-8 text data).
        - 2: binary frame.
        - 8: connection close frame; leads to the connection being terminated.
        - 9: ping frame
        - 10: pong frame
    - Mask, Masking key, (Extended) payload length, Payload data: Masking is applied from the client to the server to protect against specific security risks associated with WebSocket communication, such as cross-protocol attacks and interference by intermediaries. The server does not need to mask its messages to the client because the client is considered to be in a more secure and controlled environment, and masking would only add unnecessary overhead.

## Data flow
Find a diagram shows how data flows between an websockets application and a remote endpoint. It applies regardless of which side is the server or the client.
[Image From python websockets library doc](https://websockets.readthedocs.io/en/stable/topics/design.html)
<img src="./protocol.svg"  title="Image from python websockets library doc" alt="Image from python websockets library doc"/>

## Websocket API Design
The WebSocket protocol enables two-way communication between a client and server over a persistent connection without enforcing a specific message format. Messages can be sent in two primary formats:

- Text Messages (Opcode 1): These are sent as UTF-8 encoded strings.
- Binary Messages (Opcode 2): These consist of binary data.

Still, there are several API specification formats and standards that can be used for WebSockets, although they are less standardized compared to REST APIs. Here are some of the most commonly used formats:

- **AsyncAPI** is the most comprehensive and purpose-built specification for WebSocket and other asynchronous APIs.
- **OpenAPI (with Extensions)** is useful if you want to keep WebSocket API documentation consistent with REST API documentation.
- **WAMP** is more of a protocol but includes its own specifications for WebSocket communication.
- **RAML** can be extended for WebSockets but is less common for this use case.
- Custom Documentation Formats, ex: 
  ```go
  /**
  {
    "type": "message_type",
    "payload": {
        // payload
    },
    "timestamp": "2024-08-15T12:34:56Z",
    "meta": {
        "source": "client_id",
        "destination": "room_id"
    }
  }

  **/
  func handleWebSocketStreamConnectMessage(ctx context.Context, msgReq StreamWSMessageRequest) error {
    switch msgReq.Type {
    case WSMessageTypeChatRoomAction:
      var actionPayload ChatRoomActionRequest
      if err := json.Unmarshal(msgReq.Payload, &actionPayload); err != nil {
        return err
      }
      // handling action

    case WSMessageTypeChat:
      var chatMsgPayload ChatRoomMessageRequest
      if err := json.Unmarshal(msgReq.Payload, &chatMsgPayload); err != nil {
        return err
      }
      // handle message
    }
    return nil
  }
  ```



## WebSocket Security

### WSS
Use secure `wss://` protocol over the vulnerable `ws://` transport,  similar to the preference for `https://` over `http://`. WSS encrypts WebSocket connections, safeguarding against man-in-the-middle attacks.

### Validate Transported message
Validate client message before processing it to avoid SQL injection, and validate server message to avoid unexpected errors.

### Authentication/Authorization
1. Send Access Token in the Query Parameter

    Unlike HTTP, which mandates authentication credentials for each request, WebSockets establish a persistent connection. Authentication occurs during the initial HTTP handshake before the connection is upgraded to WebSocket, allowing subsequent communication without repeated credential checks.
      ```sh
      wss://website.com?token=your_token_here
      ```
    If the token is valid, proceed with the WebSocket upgrade. Otherwise, send a standard 401 Unauthorized response and close the underlying socket.

2. Send Access Token Over WebSocket
    Another way to authenticate a WebSocket connection is to send the access token in the first message after establishing the connection. The server should validate the token before allowing any client actions.
    However, this approach has drawbacks:

    - Increased Complexity: Implementing a custom stateful protocol adds complexity, requiring session management, synchronization across scales, and addressing inconsistencies. If issues arise, it could block logins or introduce security vulnerabilities.

    - Vulnerability to DoS Attacks: Attackers might open multiple WebSocket connections without authenticating, tying up server resources. This requires strict timeouts to prevent server overload, adding more complexity compared to HTTP-based methods.



## References:
- [The WebSocket API and protocol explained](https://ably.com/topic/websockets)
- [Writing WebSocket servers](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers)
- [Design](https://websockets.readthedocs.io/en/stable/topics/design.html)
- [rfc6455](https://datatracker.ietf.org/doc/html/rfc6455#section-5.2)
- [overview_of_websockets](https://noio-ws.readthedocs.io/en/latest/overview_of_websockets.html)
- [Are there any API specification formats for WebSockets?](https://dev.to/idanarye/are-there-any-api-specification-formats-for-websockets-2mkk)
- [Writing_WebSocket_client_applications](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications)
- [websocket-authentication](https://ably.com/blog/websocket-authentication)
- [how-to-do-authentication-over-web-sockets](https://stackoverflow.com/questions/67487034/how-to-do-authentication-over-web-sockets)
- [the-websocket-handbook](https://pages.ably.com/hubfs/the-websocket-handbook.pdf)
- [websockets-in-microservices-architecture](https://www.geeksforgeeks.org/websockets-in-microservices-architecture/)
- [WebSocket Security](https://devcenter.heroku.com/articles/websocket-security)
- [Websocket Security](https://stackoverflow.com/questions/31564432/websocket-security)
- [web cache poisoning](https://portswigger.net/web-security/web-cache-poisoning)